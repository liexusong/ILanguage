Welcome to I! I is a language in the spirit of J and Lisp, which
generalizes the array and functional capabilities of J to deal with a much
broader variety of data structures.

After building I, you will have a simple (VERY simple) command-line
interpreter, which accepts one-line-long commands.
Commands and their ouputs will be printed here as you would see them on
the command line--input line, then output line.

Every entity in I is an operation (or function).
Syntactically, every I operation is an infix function, which means that
every one takes exactly two arguments.
For operations like the standard four of arithmetic, this looks just like
normal math.
3*4 - 6/3
10
SMALL NOTE: currently / on integers is integer division, i.e. divide, and
  round to an integer. This is wrong, and will be fixed. Use floats like
  3.0 for the time being.
Numbers are also operators. They return themselves:
3 4 5
4
This behavior would seem to prevent prefix operations like - meaning
negation. However, there is an I operator . which applies the right
argument to the left argument, so we have
3.-
_3
That's a shorthand for negative three, which isn't constrained by our
operator notation. It's useful.
Note that we just took - as an argument to another operator.
That's completely ordinary, because everything is an operator. It's not
really that much different from writing 3+4 or 3.4 , which gives 4 because
4 is a constant operator.
Take note: this is opposite from the order of evaluation in most
languages! Everthing goes left to right in I. It's like telling a story.
It's fun! Well, it will be fun after you learn it. It will be absolute
hell for a little while at the beginning.
NOTE: Sometimes functions of one and two arguments will be called "monads"
  and "dyads," respectively, to save time.

    ORDER OF OPERATIONS
Order of operations proceeds from left to right.
Parentheses may be used to specify the order, but there's a (usually)
better way as well: whitespace! Fewer spaces means the function will be
executed earlier.
For example, the expression
b.-   +,-   b.q - 4*a*c . Q   /   2*a
parenthesizes as
((b.-)(+,-)(((b.q)-((4*a)*c)).Q))/(2*a)
I tend to think the first is JUST A LITTLE nicer to look at.
Note that I used three spaces around +,- and / where two would have
sufficed. Using excessive space around operations that are next to long
bits of code is recommended for sanity; it's also extremely good practice
to place the same amount of space on both sides of an operator.
This is because EVERY token can be an operator. If you don't follow the
rule, you will quickly confuse which tokens are operators and which are
operands.
As an example of things you don't want to do, look at this innocuous
little bit of code:
27 / 1+2  -1/2
1
Um. If you're willing to do the math, you'll notice that this should be
(9-1)/2 = 4. What happened?
(27 / 1+2)-1/2
4
(27 / 1+2)(-1/)2
1
In the first version, parenthesizing lets us place the two simple
operations we want to do right next to the complicated expression. This is
the right way to do it. The second is what actually happened: (-1/) got
grouped together (because it was the leftmost three operations in the
groups at the right), and the 1 (a constant operation, remember) ate
everything.
The precedence of an operator is actually the maximum of the number of
spaces on either side. This rule is pretty good, but not perfect; keep the
same number of spaces on either side of operators if you don't want to run
into the corners.

    TOKENIZATION
Tokens may be of five types:
  One alphabetic or ASCII special character. This is a built-in operator.
  A number, which starts with a numeric, contains numerics, and may contain
    a decimal point with numerics immediately surrounding (no whitespace).
    Numbers can also start with _, which indicates negation.
  A name, which is set off by single quotes and can contain any sequence
    of characters which are not single quotes.
  A string, set off by double quotes. Additional double quotes are escaped
    by doubling, as in "The character "" is a double quote.".
  A quasiquote, set off by backquotes and reserved for system functions.

Numbers and strings are constants; when applied as operators they'll
return themselves. Names can represent anything, as can quasiquotes,
although neither of these are implemented yet. Soon... very soon...
Builtins are the soul of I. They provide all the functionality you need
to build functions. No lambdas... no "define" constructs... just builtins.

    OPERATIONS
The available operations are detailed in the other files in this folder.
Aside from the information here, the ONLY things you need to learn about
I are which functions are built in and which data structures are defined.
After you finish this document, take a look around!

    BOOLEANS
Things which aren't zero are true, and things which are zero are false.
There are no dedicated boolean types. 0 and 1 will be treated as the
canonical booleans, to be returned by functions which purport to return
booleans.

    OKAY, HOW DO I USE THIS STUFF?
It's, uh, different. Composing an operation basically involves taking
other operations as steps and combining them appropriately. Composition
operations are crucial here, and are listed in compose.txt. For example,
function composition is o . It's meant to evoke mathematical composition,
but it goes in the other direction and a better translation is "then."
As an example, look at
4 *o- 5
_20
The operation here is *o- , "Multiply then negate." The right operand of
o is always invoked with only one argument, while the left can take one or
two (try (6 . /o-) , where / with one argument is the reciprocal, for an
example).
Another composition is O , which makes sure the LEFT operand is applied as
a single-argument function by applying it to each operand. For example,
2.0 /O+ 0.4
3.000000
2.0./ + 0.4./
3.000000
The reason we use compositions like this is to compress a function that
originally had the arguments sprinkled all over the place to one that has
arguments only on the left and possibly right. After that, we can either
assign them or pass them as arguments to other functions. For an example
of this functionality, we introduce b , or "bind," which fixes its right
argument as an operand of its left, to be applied to one more argument
as the right argument:
2 . *b3
6
and w , or while, which executes the left argument while the right one is
true of its operands (so (a . fwg) applies f to a until g returns false.
Now let's generate the first power of two after 1000:
1  .  *b2 w <b1000
1024
I would read that as "Take one, and multiply by two while it's less than
one thousand." Solves the problem.
Expect more guided examples in the future. But not in the present.
Because I haven't written them yet.

    MAPPING
The one-argument form of o does something similar to the two-argument
form. I think an example is best:
5  - *.o +  4
9
5-4 * 5+4
9
Apply both the left and the right functions, and apply the middle one to
the two results. For those interested, difference of squares tells us
that's equal to (5 qO- 4) , or
"five and four--square 'em both, and subtract."
But what if, magically, we didn't have to write the o ? If I knew what we
wanted to do and we could just say "the difference times the sum?"
Go ahead; try it.
5 -*+ 4
9
Worked. How?

Every operation has a domain to which it can reasonably apply (for example,
arithmetic functions can only apply to numbers).
If an operation is applied to something outside of its domain, it attempts
to "map" over the argument by a method defined as part of the data
structure. Mapping over a function is composition like we saw. For one
argument, that changes things like *.- into *o- . Essentially, we are
applying - not to * , but to the RESULT of * . It's a pretty natural way
to think about this, and in fact it's applied pretty much universally in
mathematics (think f+g), but never acknowledged meaningfully.
The mapping operation for a collection is to apply the function to
each element of the collection and give the collection of results.
See for example
1,2,3 * 2,3,4
 2;6,12 
Once sets are implemented, you'll also be able to take a set like {_2,2}
(not the actual notation) and square it. You'll get {4}.
For a more in-depth treatment of the subject, see
https://docs.google.com/open?id=0B9JcSIlTRG6FZjA1NjE4ZTgtYzhiYy00YzA0LTkxODUtZDUwODg5OGEwYmE5

Data structures and their mapping methods are given in the relevant
documentation files here.
Functions are always given with their domain; if unstated, it defaults
to true.
